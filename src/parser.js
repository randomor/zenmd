import fs from "fs/promises";
import remarkParse from "remark-parse";
import remarkGfm from "remark-gfm";
import remarkRehype from "remark-rehype";
import remarkWikiLink from "remark-wiki-link";
import remarkFrontmatter from "remark-frontmatter";
import remarkParseFrontmatter from "remark-parse-frontmatter";
import rehypeSlug from "rehype-slug";
import rehypeRaw from "rehype-raw";
import rehypeStringify from "rehype-stringify";
import rehypeAutolinkHeadings from "rehype-autolink-headings";
import rehypeInferTitleMeta from "rehype-infer-title-meta";
import path from "path";
import chalk from "chalk";
import { unified } from "unified";
import { visit } from "unist-util-visit";
// Sync fs functions removed as findImageRecursiveSync is being removed
import { normalizePath, isUrl, findImageRecursive } from "./utils.js";

export const configParser = (
  currentFile,
  inputFolder,
  outputFileFolder,
  imageDir = ""
) => {
  const relativePathToInputFolder = path.relative(
    path.dirname(currentFile),
    inputFolder
  );

  const processor = unified()
    .use(remarkParse)
    .use(remarkFrontmatter)
    .use(remarkParseFrontmatter)
    // 1. remarkWikiLink: Parses [[wikiLinks]] and ![[embeds]] into 'wikiLink' mdast nodes.
    // data.isEmbed will be true for ![[embeds]].
    .use(remarkWikiLink, {
      pageResolver: (name) => [
        path.join(relativePathToInputFolder, normalizePath(name)),
      ],
      hrefTemplate: (permalink) => `${permalink}.html`, // Only for non-embed links
    })
    // 2. remarkGfm: Standard GFM processing.
    // Obsidian image embeds are now pre-processed into standard Markdown images
    // so no special remark plugin is needed for them here.
    .use(remarkGfm)
    // 4. Link normalizer for .md extensions in standard links.
    .use(() => (tree) => {
      visit(tree, "link", (node) => {
        if (!isUrl(node.url) && node.url.match(/\.md$/)) {
          node.url = normalizePath(node.url).replace(/\.md$/, ".html");
        }
      });
    })
    // 5. Standard Markdown image URL decoder: For standard ![]() images,
    // ensures URL is decoded. Path remains relative to the MD file.
    .use(() => (tree) => {
      visit(tree, "image", (node) => {
        if (node.url && !isUrl(node.url)) {
          node.url = decodeURI(node.url);
        }
      });
    })
    // 6. remarkRehype: Converts Markdown AST (mdast) to HTML AST (hast).
    // 'html' mdast nodes (from remarkObsidianImageEmbeds) will be passed through.
    // 'image' mdast nodes will be converted to <img> elements in hast.
    .use(remarkRehype, { allowDangerousHtml: true })
    // 7. rehypeRaw: Parses raw HTML content within the hast.
    // This is crucial for the <img> tags generated by remarkObsidianImageEmbeds
    // to become actual 'element' nodes in the hast.
    .use(rehypeRaw)
    // 8. rehypeSlug: Adds 'id' attributes to headings.
    .use(rehypeSlug)
    // 9. Unified Rehype Image Processor: Handles all <img> elements in the hast.
    // This plugin copies image files and adjusts their 'src' paths.
    .use(() => (tree) => {
      const promises = [];
      visit(tree, "element", (node) => {
        if (
          node.tagName === "img" &&
          node?.properties?.src &&
          !isUrl(node.properties.src)
        ) {
          const imageSrcOriginal = node.properties.src;
          const decodedUrl = decodeURI(imageSrcOriginal); // Path relative to MD file (e.g., "image.png" or "assets/image.png")

          // targetHref is path relative to output HTML file's directory, including imageDir and original subdirectories.
          // E.g., if imageDir="img_assets", decodedUrl="sub/pic.png", then targetHref="img_assets/sub/pic.png".
          // If imageDir="", decodedUrl="foo/bar.png", targetHref="foo/bar.png".
          const targetHref = path.join(imageDir, decodedUrl).replace(/\\/g, "/");

          const outputPathAbsolute = path.join(outputFileFolder, targetHref);
          const currentFileDir = path.dirname(currentFile);
          const sourceImagePathAbsolute = path.resolve(currentFileDir, decodedUrl);

          promises.push(
            fs.mkdir(path.dirname(outputPathAbsolute), { recursive: true })
              .then(() => fs.copyFile(sourceImagePathAbsolute, outputPathAbsolute))
              .catch(error => {
                console.error(
                  chalk.red(
                    `Error copying image from ${sourceImagePathAbsolute} to ${outputPathAbsolute}: ${error.message}`
                  )
                );
                // Optionally rethrow or handle error
              })
          );
          // Update the src to be relative to the HTML file's location, with URL encoding for path segments
          const encodedTargetHref = targetHref.split('/').map(encodeURIComponent).join('/');
          node.properties.src = `./${encodedTargetHref}`;
        }
      });
      if (promises.length > 0) {
        return Promise.all(promises).then(() => tree);
      }
      return tree;
    })
    .use(rehypeAutolinkHeadings, {
      behavior: "append",
    })
    .use(rehypeInferTitleMeta)
    .use(rehypeStringify, { allowDangerousHtml: true });

  return processor;
};

export const parseMarkdown = async (
  inputFile,
  inputFolder,
  outputFolder,
  options = { tags: [] }
) => {
  const relativePath = path.relative(inputFolder, inputFile);
  const outputFileFolder = path.join(
    outputFolder,
    path.dirname(normalizePath(relativePath))
  );
  const inputFileName = normalizePath(path.parse(inputFile).name);
  const outputFileName = `${inputFileName}.html`;
  const outputFilePath = path.join(outputFileFolder, outputFileName);

  console.log(chalk.blue("Converting: ", inputFile, outputFileFolder));
  try {
    let data = await fs.readFile(inputFile, "utf8"); // Use let as data will be modified

    // Pre-processing step for Obsidian image embeds ![[...]]
    const imageEmbedRegex = /\!\[\[(.*?)\]\]/g;
    const matches = [];
    let regexMatch;
    while ((regexMatch = imageEmbedRegex.exec(data)) !== null) {
      matches.push({
        fullMatch: regexMatch[0], // e.g., ![[image.png]]
        capturedPath: regexMatch[1], // e.g., image.png
        index: regexMatch.index,
      });
    }

    const currentFileDir = path.dirname(inputFile);
    const replacementValues = [];

    for (const item of matches) {
      const decodedUserPath = decodeURIComponent(item.capturedPath);
      let effectivePath = decodedUserPath; // Default to original path

      const foundImagePath = await findImageRecursive(decodedUserPath, currentFileDir);

      if (foundImagePath) {
        // foundImagePath is already relative to currentFileDir
        effectivePath = foundImagePath;
      } else {
        console.warn(
          chalk.yellow(
            `[Warning] Image "${decodedUserPath}" not found in directory or subdirectories of "${inputFile}". Using original path link.`
          )
        );
      }

      const finalEncodedPath = effectivePath
        .split("/")
        .map(encodeURIComponent) // Encode each path segment
        .join("/");
      replacementValues.push({
        fullMatch: item.fullMatch,
        replacementString: `![](./${finalEncodedPath})`,
      });
    }

    // Perform replacements. Iterating backwards is safer if there were index-based replacements.
    // For string-based replacement, order doesn't strictly matter unless replacements create new matches.
    // Here, each `fullMatch` is distinct for ![[...]] embeds due to the captured path.
    for (const r of replacementValues) {
      data = data.replace(r.fullMatch, r.replacementString);
    }

    const processor = await configParser(
      inputFile,
      inputFolder,
      outputFileFolder
    );
    const file = await processor.process(data);
    const frontMatter = file.data.frontmatter || {};

    // match front matter with tags and return if not match
    const tags = options.tags || [];
    if (tags.length > 0) {
      const shouldRender = tags.every(([key, value]) => {
        if (value === "true") {
          return frontMatter[key] && frontMatter[key].toString() === value;
        } else if (value === "false") {
          return !frontMatter[key] || frontMatter[key].toString() !== "true";
        } else {
          return true;
        }
      });
      console.log(
        chalk.yellow("Frontmatter::::", frontMatter, tags, shouldRender)
      );
      if (!shouldRender) {
        console.log(chalk.yellow(`Skipped: ${inputFile}`));
        return;
      }
    }

    const htmlContent = String(file.value);

    const title = file.data.meta?.title || frontMatter.title || inputFileName;
    const description = frontMatter.description || `A page about ${title}`;

    if (Object.keys(frontMatter).length > 0) {
      console.log(chalk.blueBright("Front Matter:"), frontMatter);
    }

    try {
      await fs.access(outputFileFolder);
    } catch (error) {
      await fs.mkdir(outputFileFolder, { recursive: true });
    }
    console.log(chalk.greenBright(`Parsed: ${outputFilePath}`));

    return {
      title,
      description,
      content: htmlContent,
      frontMatter,
      inputFile,
      inputFolder,
      outputFileFolder,
      outputFileName,
      outputFilePath,
    };
  } catch (err) {
    console.error(chalk.red(`Error parsing file ${inputFile}:`), err);
  }
};
// Removed findImageRecursiveSync function
